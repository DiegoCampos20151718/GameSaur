var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
import fs from 'fs-extra';
import path from 'path';
import os from 'os';
import { log, confirm } from '@clack/prompts';
import { cloneRepositoryAtRoot, dashToPascal, getAllComponents } from '..';
import { generateConfigAndInstallDependencies } from '../create-config';
import configData from '../../../config.json';
const currDir = process.cwd();
const homeDir = os.homedir();
let existingComponentsChecked = false;
const componentAdder = ({ requestedComponent = '', showWarning = true, installationMethod = '', }) => __awaiter(void 0, void 0, void 0, function* () {
    try {
        yield cloneRepositoryAtRoot();
        if (requestedComponent &&
            requestedComponent !== '--all' &&
            !(yield checkIfComponentIsValid(requestedComponent))) {
            log.error('\x1b[32m' +
                `The ${requestedComponent} does not exist. Kindly choose from the below list.` +
                '\x1b[0m');
            return;
        }
        let requestedComponents = requestedComponent === '--all'
            ? getAllComponents()
            : [dashToPascal(requestedComponent)];
        const updatedComponents = !existingComponentsChecked && showWarning && requestedComponent
            ? yield isComponentInConfig(requestedComponents)
            : requestedComponents;
        const folderExist = yield checkIfDirectoryExists(path.join(currDir, configData.writableComponentsPath));
        if (!folderExist)
            updatedComponents.push('GluestackUIProvider');
        yield Promise.all(updatedComponents.map((component) => __awaiter(void 0, void 0, void 0, function* () {
            const targetPath = path.join(currDir, configData.writableComponentsPath, component);
            yield writeComponent(component, targetPath);
            addIndexFile(path.join(currDir, configData.writableComponentsPath));
        })))
            .then(() => __awaiter(void 0, void 0, void 0, function* () {
            yield generateConfigAndInstallDependencies(path.join(currDir, configData.writableComponentsPath), installationMethod);
            log.success('Installation completed');
        }))
            .catch((err) => {
            log.error(`\x1b[31mError : ${err.message}\x1b[0m`);
        });
    }
    catch (err) {
        log.error(`\x1b[31mError: ${err.message}\x1b[0m`);
    }
});
const checkIfDirectoryExists = (path) => __awaiter(void 0, void 0, void 0, function* () {
    try {
        const stats = yield fs.stat(path);
        return stats.isDirectory();
    }
    catch (error) {
        return false; // Directory does not exist or there was an error accessing it
    }
});
const isComponentInConfig = (components) => __awaiter(void 0, void 0, void 0, function* () {
    const alreadyExistingComponents = [];
    let componentsToAdd = [];
    for (const component of components) {
        const pathToCheck = path.join(currDir, configData.writableComponentsPath, component);
        if (fs.existsSync(pathToCheck)) {
            alreadyExistingComponents.push(component);
        }
    }
    //confirm about the already existing components
    if (alreadyExistingComponents.length === 1 ||
        alreadyExistingComponents.length > 1) {
        const shouldContinue = yield confirmOverride(alreadyExistingComponents, alreadyExistingComponents.length);
        //code to remove already existing components from the list
        componentsToAdd = shouldContinue
            ? components.filter((component) => !alreadyExistingComponents.includes(component))
            : processTerminate('Installation aborted');
        if (shouldContinue) {
            componentsToAdd = components;
        }
        else {
            componentsToAdd = [];
        }
    }
    else {
        componentsToAdd = components;
    }
    if (componentsToAdd.length === 0)
        log.error('No components to be added');
    existingComponentsChecked = true;
    return componentsToAdd;
});
const processTerminate = (message) => {
    log.error(message);
    process.exit(1);
};
const checkIfComponentIsValid = (component) => __awaiter(void 0, void 0, void 0, function* () {
    const componentList = getAllComponents();
    if (componentList.includes(component) ||
        componentList.includes(dashToPascal(component)))
        return true;
    else
        return false;
});
const writeComponent = (component, targetPath) => __awaiter(void 0, void 0, void 0, function* () {
    try {
        // Ensure the destination folder exists or create it
        yield fs.ensureDir(targetPath);
        yield fs.copy(path.join(homeDir, configData.gluestackDir, configData.componentsPath, component, 'index.tsx'), path.join(targetPath, 'index.tsx'), {
            overwrite: true,
        });
    }
    catch (error) {
        log.error(`\x1b[31mError: ${error.message}\x1b[0m`);
    }
});
const addIndexFile = (componentsDirectory) => __awaiter(void 0, void 0, void 0, function* () {
    try {
        const directories = yield fs.readdir(componentsDirectory);
        const componentDirectories = directories.filter((item) => fs.statSync(path.join(componentsDirectory, item)).isDirectory());
        // Generate import and export statements for each component directory
        const exportStatements = componentDirectories
            .map((component) => `export * from './${component}';`)
            .join('\n');
        const indexContent = `${exportStatements}\n`;
        yield fs.writeFile(path.join(componentsDirectory, 'index.ts'), indexContent);
    }
    catch (err) {
        log.error(`\x1b[31mError: ${err.message}\x1b[0m`);
    }
});
const confirmOverride = (component, existingCount) => __awaiter(void 0, void 0, void 0, function* () {
    const displayComponent = existingCount === 1 ? component[0] : 'Few';
    const shouldContinue = yield confirm({
        message: `${displayComponent} component/components already exists. Be advised that if there are any changes made in the components, proceeding will result in components being replaced as well. Continue installing component?`,
    });
    return shouldContinue;
});
export { componentAdder, getAllComponents };
