var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
import * as fs from 'fs';
import * as os from 'os';
import * as path from 'path';
import { generateSpecificFile, installPackages, replaceRelativeImportInFile, } from '.';
import { log } from '@clack/prompts';
import configData from '../../config.json';
const currDir = process.cwd();
const homeDir = os.homedir();
let installDependencies = [];
const congifPath = path.join(process.cwd(), 'components', 'gluestack-ui.config.ts');
function configCleanup(directoryPath) {
    return __awaiter(this, void 0, void 0, function* () {
        try {
            // Read all files in the directory
            const entries = fs.readdirSync(directoryPath, { withFileTypes: true });
            // Filter out directories from the list of entries
            const directories = entries.filter((entry) => entry.isDirectory());
            // Iterate over each directory
            directories.forEach((directory) => {
                const componentPath = path.join(directoryPath, directory.name);
                const configPath = path.join(componentPath, 'config.json');
                if (fs.existsSync(configPath)) {
                    fs.unlinkSync(configPath);
                }
            });
        }
        catch (error) {
            log.error(`\x1b[31mError :  Error occurred during config cleanup: ${error.message}\x1b[0m`);
        }
    });
}
function fetchAndInstallPackages(installationMethod = 'npm') {
    return __awaiter(this, void 0, void 0, function* () {
        const componentsDir = path.join(currDir, 'components');
        let allPackages = [];
        // Read all directories in the components directory
        const componentDirectories = fs
            .readdirSync(componentsDir, { withFileTypes: true })
            .filter((dirent) => dirent.isDirectory())
            .map((dirent) => dirent.name);
        // Iterate over each component directory
        componentDirectories.forEach((componentName) => {
            const configPath = path.join(componentsDir, componentName, 'config.json');
            try {
                const configData = JSON.parse(fs.readFileSync(configPath, 'utf8'));
                const { installDependencies } = configData;
                // Add installDependencies to allPackages array
                allPackages.push(...installDependencies);
            }
            catch (error) {
                log.error(`Error reading config.json for ${componentName}: ${error.message}`);
            }
        });
        yield installPackages(installationMethod, allPackages);
        yield configCleanup(path.join(currDir, 'components'));
    });
}
// Function to parse imports from a TypeScript file
function parseImports(filePath) {
    const content = fs.readFileSync(filePath, 'utf-8');
    const imports = content.match(/import\s+{[^}]+}\s+from\s+["']([^"']+)["']/g);
    if (imports) {
        return imports
            .map((importStatement) => {
            const importPath = importStatement.match(/from\s+["']([^"']+)["']/)[1];
            // Exclude imports from current directory (./) or parent directory (../)
            if (!importPath.startsWith('./') && !importPath.startsWith('../')) {
                return importPath;
            }
        })
            .filter(Boolean); // Filter out undefined values
    }
    return [];
}
function generateConfig(rootDir, currentComponent) {
    return __awaiter(this, void 0, void 0, function* () {
        const componentConfig = {
            installDependencies: [],
        };
        const componentImports = parseImports(path.join(rootDir, currentComponent, 'index.tsx'));
        componentImports.forEach((importedPackage) => {
            if (importedPackage.startsWith('@gluestack-ui/')) {
                const componentName = importedPackage.split('/')[1];
                if (currentComponent === 'GluestackUIProvider' &&
                    componentName !== undefined) {
                    installDependencies.push(importedPackage);
                }
                if (componentName !== undefined) {
                    componentConfig.installDependencies.push(importedPackage);
                }
            }
            else {
                if (!installDependencies.includes(importedPackage)) {
                    installDependencies.push(importedPackage);
                }
            }
        });
        if (currentComponent !== 'GluestackUIProvider')
            fs.writeFileSync(path.join(rootDir, currentComponent, 'config.json'), JSON.stringify(componentConfig, null, 2));
    });
}
function getConfigDependencies(filePath) {
    return __awaiter(this, void 0, void 0, function* () {
        const fileImports = parseImports(filePath);
        fileImports.forEach((fileImports) => {
            if (!installDependencies.includes(fileImports)) {
                installDependencies.push(fileImports);
            }
        });
    });
}
// Main function to start generating config files
function generateConfigAndInstallDependencies(rootDir, installationMethod) {
    return __awaiter(this, void 0, void 0, function* () {
        const allComponents = yield fs.readdirSync(path.join(currDir, configData.writableComponentsPath));
        allComponents.forEach((component) => {
            const componentPath = path.join(currDir, configData.writableComponentsPath, component);
            const stats = fs.statSync(componentPath);
            if (stats.isDirectory()) {
                generateConfig(rootDir, component);
            }
        });
        yield generateSpecificFile(path.join(homeDir, configData.configResourcepath), congifPath, 'gluestack-ui.config.ts');
        yield getConfigDependencies(path.join(currDir, 'components', 'gluestack-ui.config.ts'));
        if (fs.existsSync(path.join(rootDir, 'GluestackUIProvider'))) {
            fs.writeFileSync(path.join(rootDir, 'GluestackUIProvider', 'config.json'), JSON.stringify({ installDependencies }, null, 2));
        }
        const oldImportPath = './config';
        const newImportPath = '../gluestack-ui.config';
        yield replaceRelativeImportInFile(path.join(currDir, 'components', 'GluestackUIProvider', 'index.tsx'), oldImportPath, newImportPath);
        yield fetchAndInstallPackages(installationMethod);
    });
}
export { generateConfigAndInstallDependencies };
