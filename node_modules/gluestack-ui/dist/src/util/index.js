var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
import os from 'os';
import path from 'path';
import util from 'util';
import fs from 'fs-extra';
import { log, spinner, confirm, isCancel, cancel, select, } from '@clack/prompts';
import finder from 'find-package-json';
import simpleGit from 'simple-git';
import { spawnSync } from 'child_process';
// const configData = require('../../config.json');
import configData from '../../config.json';
const stat = util.promisify(fs.stat);
const homeDir = os.homedir();
const currDir = process.cwd();
const getPackageJsonPath = () => {
    var f = finder(currDir);
    return f.next().filename || '';
};
const rootPackageJsonPath = getPackageJsonPath();
const projectRootPath = path.dirname(rootPackageJsonPath);
const getAllComponents = () => {
    const componentList = fs
        .readdirSync(path.join(homeDir, configData.gluestackDir, configData.componentsPath))
        .filter((file) => !['.tsx', '.ts', '.jsx', '.js'].includes(path.extname(file).toLowerCase()));
    return componentList;
};
const dashToPascal = (str) => {
    return str
        .toLowerCase()
        .replace(/-(.)/g, (_, group1) => group1.toUpperCase())
        .replace(/(^|-)([a-z])/g, (_, _group1, group2) => group2.toUpperCase());
};
const cloneRepositoryAtRoot = () => __awaiter(void 0, void 0, void 0, function* () {
    const clonedRepoExists = yield checkIfFolderExists(path.join(homeDir, configData.gluestackDir));
    if (clonedRepoExists) {
        log.step('Repository already cloned.');
        yield pullComponentRepo(path.join(homeDir, configData.gluestackDir));
    }
    else {
        const s = spinner();
        s.start('Cloning repository...');
        yield cloneComponentRepo(path.join(homeDir, configData.gluestackDir), configData.repoUrl);
        s.stop('Repository cloned successfully.');
    }
});
const cloneComponentRepo = (targetPath, gitURL) => __awaiter(void 0, void 0, void 0, function* () {
    const git = simpleGit();
    const s = spinner();
    s.start('⏳ Cloning repository...');
    try {
        yield git.clone(gitURL, targetPath);
        s.stop('\x1b[32m' + 'Cloning successful.' + '\x1b[0m');
    }
    catch (err) {
        s.stop('\x1b[31m' + 'Cloning failed' + '\x1b[0m');
        log.error(`\x1b[31mError: ${err.message}\x1b[0m`);
    }
});
const pullComponentRepo = (targetpath) => __awaiter(void 0, void 0, void 0, function* () {
    const s = spinner();
    s.start('⏳ Pulling latest changes...');
    let retry = 0;
    let success = false;
    while (!success && retry < 3) {
        try {
            yield wait(1000);
            yield tryGitPull(targetpath);
            success = true;
        }
        catch (err) {
            log.error(`\x1b[31mError: ${err.message}\x1b[0m`);
            log.error(`\x1b[31mPulling failed - retrying... (Attempt ${retry + 1})\x1b[0m`);
            retry++;
        }
    }
    if (!success)
        s.stop('\x1b[31m' + 'Pulling failed!' + '\x1b[0m');
    else
        s.stop('\x1b[32m' + 'Git pull successful.' + '\x1b[0m');
});
const tryGitPull = (targetPath) => __awaiter(void 0, void 0, void 0, function* () {
    const git = simpleGit(targetPath);
    if (fs.existsSync(targetPath)) {
        yield git.pull('origin', 'main');
    }
    else
        log.error('\x1b[31m' + 'Target path does not exist' + '\x1b[0m');
});
function getLatestReleaseBranch() {
    return __awaiter(this, void 0, void 0, function* () {
        try {
            const git = simpleGit(path.join(homeDir, configData.gluestackDir));
            yield git.fetch(['--all']);
            const { all: remoteBranches } = yield git.branch(['-r']);
            // Filter out release branches
            const releaseBranches = remoteBranches.filter((branch) => /^origin\/release\/\d+\.\d+\.\d+$/.test(branch));
            let latestReleaseBranch = null;
            let latestVersion = null;
            // Find the latest release branch
            releaseBranches.forEach((branch) => {
                const versionMatch = branch.match(/release\/(\d+\.\d+\.\d+)$/);
                if (versionMatch) {
                    const version = versionMatch[1]; // Extracting the version from the capturing group
                    if (!latestVersion || compareVersions(version, latestVersion) > 0) {
                        latestVersion = version;
                        latestReleaseBranch = branch;
                    }
                }
            });
            return latestReleaseBranch;
        }
        catch (error) {
            log.error(`\x1b[31mError: ${error.message}\x1b[0m`);
            return null;
        }
    });
}
function compareVersions(version1, version2) {
    const parts1 = version1.split('.').map(Number);
    const parts2 = version2.split('.').map(Number);
    for (let i = 0; i < Math.max(parts1.length, parts2.length); i++) {
        const part1 = parts1[i] || 0;
        const part2 = parts2[i] || 0;
        if (part1 > part2) {
            return 1;
        }
        else if (part1 < part2) {
            return -1;
        }
    }
    return 0; // Versions are equal
}
const checkIfFolderExists = (path) => __awaiter(void 0, void 0, void 0, function* () {
    try {
        const stats = yield stat(path);
        return stats.isDirectory();
    }
    catch (error) {
        return false;
    }
});
const wait = (msec) => new Promise((resolve, _) => {
    setTimeout(resolve, msec);
});
const detectLockFile = () => {
    const packageLockPath = path.join(projectRootPath, 'package-lock.json');
    const yarnLockPath = path.join(projectRootPath, 'yarn.lock');
    const pnpmLockPath = path.join(projectRootPath, 'pnpm-lock.yaml');
    if (fs.existsSync(packageLockPath)) {
        return 'npm';
    }
    else if (fs.existsSync(yarnLockPath)) {
        return 'yarn';
    }
    else if (fs.existsSync(pnpmLockPath)) {
        return 'pnpm';
    }
    else {
        return null;
    }
};
const promptVersionManager = () => __awaiter(void 0, void 0, void 0, function* () {
    const packageManager = yield select({
        message: 'No lockfile detected. Please select a package manager to install dependencies:',
        options: [
            { value: 'npm', label: 'npm', hint: 'recommended' },
            { value: 'yarn', label: 'yarn' },
            { value: 'pnpm', label: 'pnpm' },
        ],
    });
    if (isCancel(packageManager)) {
        cancel('Operation cancelled.');
        process.exit(0);
    }
    return packageManager;
});
const addDependencies = (dependenciesToAdd) => __awaiter(void 0, void 0, void 0, function* () {
    const packageJsonPath = rootPackageJsonPath;
    try {
        // Read in the existing package.json file
        const packageJson = JSON.parse(fs.readFileSync(packageJsonPath, 'utf8'));
        packageJson.dependencies = packageJson.dependencies || {};
        // Add each dependency in the provided format
        dependenciesToAdd.forEach((packageName) => {
            packageJson.dependencies[packageName] = 'latest';
        });
        // Write the updated package.json file
        fs.writeFileSync(packageJsonPath, JSON.stringify(packageJson, null, 2));
    }
    catch (err) {
        log.error(`\x1b[31mError: ${err.message}\x1b[0m`);
    }
});
const installPackages = (installationMethod, dependencies) => __awaiter(void 0, void 0, void 0, function* () {
    let command;
    if (!installationMethod) {
        let versionManager = detectLockFile();
        if (!versionManager) {
            versionManager = yield promptVersionManager();
        }
        else {
            const shouldContinue = yield confirm({
                message: `Lockfile detected for ${versionManager}. Continue with ${versionManager} install?`,
            });
            if (!shouldContinue) {
                versionManager = yield promptVersionManager();
            }
        }
        switch (versionManager) {
            case 'npm':
                command = `npm install --legacy-peer-deps `;
                break;
            case 'yarn':
                command = `yarn `;
                break;
            case 'pnpm':
                command = `pnpm i --lockfile-only `;
                break;
            default:
                throw new Error('Invalid package manager selected');
        }
    }
    else {
        switch (installationMethod) {
            case 'npm':
                command = `npm install --legacy-peer-deps`;
                break;
            case 'yarn':
                command = `yarn `;
                break;
            case 'pnpm':
                command = `pnpm i --lockfile-only`;
                break;
            default:
                throw new Error('Invalid package manager selected');
        }
    }
    const s = spinner();
    s.start('⏳ Installing dependencies...');
    try {
        yield addDependencies(dependencies);
        spawnSync(command, {
            cwd: projectRootPath,
            stdio: 'inherit',
            shell: true,
        });
        s.stop(`\x1b[32mDependencies have been installed successfully.\x1b[0m`);
    }
    catch (err) {
        log.error(`\x1b[31mError: ${err.message}\x1b[0m`);
        log.error('\x1b[31mError installing dependencies:\x1b[0m');
        log.warning(` - Run \x1b[33m'${command}'\x1b[0m manually!`);
        throw new Error('Error installing dependencies.');
    }
});
function replaceRelativeImportInFile(filePath, oldImportPath, newImportPath) {
    return __awaiter(this, void 0, void 0, function* () {
        try {
            let fileContent = fs.readFileSync(filePath, 'utf8');
            const modifiedContent = fileContent.replace(new RegExp(`import {.*} from ['"]${oldImportPath}['"];`, 'g'), `import { config } from '${newImportPath}';`);
            fs.writeFileSync(filePath, modifiedContent, 'utf8');
        }
        catch (err) {
            log.error(`Error replacing import statement: ${err}`);
        }
    });
}
// Function to copy file with checks
const generateSpecificFile = (sourcePath, targetPath, fileName) => __awaiter(void 0, void 0, void 0, function* () {
    try {
        // Check if file exists at targetPath
        const exists = yield fs.pathExists(targetPath);
        if (exists) {
            const ifConfirm = yield confirm({
                message: `File ${fileName} already exists. Do you want to overwrite it? (yes/no): `,
            });
            if (ifConfirm) {
                yield fs.copyFile(sourcePath, targetPath);
            }
            else {
                log.info(`Creating ${fileName} has been skipped...`);
                return;
            }
            // return;
        }
        else {
            // File does not exist, proceed with copying
            yield fs.copyFile(sourcePath, targetPath);
        }
    }
    catch (err) {
        log.error(`\x1b[31mError: ${err.message}\x1b[0m`);
    }
});
export { cloneRepositoryAtRoot, pullComponentRepo, checkIfFolderExists, getAllComponents, dashToPascal, generateSpecificFile, installPackages, replaceRelativeImportInFile, };
