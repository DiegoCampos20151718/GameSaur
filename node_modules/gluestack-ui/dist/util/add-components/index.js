var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
(function (factory) {
    if (typeof module === "object" && typeof module.exports === "object") {
        var v = factory(require, exports);
        if (v !== undefined) module.exports = v;
    }
    else if (typeof define === "function" && define.amd) {
        define(["require", "exports", "fs-extra", "path", "os", "@clack/prompts", "..", "../create-config", "../../config"], factory);
    }
})(function (require, exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.getAllComponents = exports.componentAdder = void 0;
    const fs_extra_1 = __importDefault(require("fs-extra"));
    const path_1 = __importDefault(require("path"));
    const os_1 = __importDefault(require("os"));
    const prompts_1 = require("@clack/prompts");
    const __1 = require("..");
    Object.defineProperty(exports, "getAllComponents", { enumerable: true, get: function () { return __1.getAllComponents; } });
    const create_config_1 = require("../create-config");
    const config_1 = require("../../config");
    const currDir = process.cwd();
    const homeDir = os_1.default.homedir();
    let existingComponentsChecked = false;
    const componentAdder = ({ requestedComponent = '', showWarning = true, installationMethod = '', }) => __awaiter(void 0, void 0, void 0, function* () {
        try {
            yield (0, __1.cloneRepositoryAtRoot)();
            yield (0, create_config_1.getComponentStyle)();
            if (requestedComponent &&
                requestedComponent !== '--all' &&
                !(yield checkIfComponentIsValid(requestedComponent))) {
                prompts_1.log.error(`\x1b[31mThe ${requestedComponent} does not exist. Kindly choose a valid component name.\x1b[0m `);
                return;
            }
            let requestedComponents = requestedComponent === '--all'
                ? (0, __1.getAllComponents)()
                : [requestedComponent];
            const updatedComponents = !existingComponentsChecked && showWarning && requestedComponent
                ? yield isComponentInConfig(requestedComponents)
                : requestedComponents;
            yield Promise.all(updatedComponents.map((component) => __awaiter(void 0, void 0, void 0, function* () {
                const targetPath = path_1.default.join(currDir, config_1.config.writableComponentsPath, component);
                yield writeComponent(component, targetPath);
                (0, __1.addIndexFile)(path_1.default.join(currDir, config_1.config.writableComponentsPath));
            })))
                .then(() => __awaiter(void 0, void 0, void 0, function* () {
                yield (0, create_config_1.generateConfigAndInstallDependencies)({
                    rootDir: path_1.default.join(currDir, config_1.config.writableComponentsPath),
                    installationMethod: installationMethod,
                });
                prompts_1.log.success('Installation completed');
            }))
                .catch((err) => {
                prompts_1.log.error(`\x1b[31mError : ${err.message}\x1b[0m`);
            });
        }
        catch (err) {
            prompts_1.log.error(`\x1b[31mError: ${err.message}\x1b[0m`);
        }
    });
    exports.componentAdder = componentAdder;
    const checkIfDirectoryExists = (path) => __awaiter(void 0, void 0, void 0, function* () {
        try {
            const stats = yield fs_extra_1.default.stat(path);
            return stats.isDirectory();
        }
        catch (error) {
            return false; // Directory does not exist or there was an error accessing it
        }
    });
    const isComponentInConfig = (components) => __awaiter(void 0, void 0, void 0, function* () {
        const alreadyExistingComponents = [];
        let componentsToAdd = [];
        for (const component of components) {
            const pathToCheck = path_1.default.join(currDir, config_1.config.writableComponentsPath, component);
            if (fs_extra_1.default.existsSync(pathToCheck)) {
                alreadyExistingComponents.push(component);
            }
        }
        //confirm about the already existing components
        if (alreadyExistingComponents.length === 1 ||
            alreadyExistingComponents.length > 1) {
            const shouldContinue = yield confirmOverride(alreadyExistingComponents, alreadyExistingComponents.length);
            //code to remove already existing components from the list
            componentsToAdd = shouldContinue
                ? components.filter((component) => !alreadyExistingComponents.includes(component))
                : processTerminate('Installation aborted');
            if (shouldContinue) {
                componentsToAdd = components;
            }
            else {
                componentsToAdd = [];
            }
        }
        else {
            componentsToAdd = components;
        }
        if (componentsToAdd.length === 0)
            prompts_1.log.error('No components to be added');
        existingComponentsChecked = true;
        return componentsToAdd;
    });
    const processTerminate = (message) => {
        prompts_1.log.error(message);
        process.exit(1);
    };
    const checkIfComponentIsValid = (component) => __awaiter(void 0, void 0, void 0, function* () {
        const componentList = (0, __1.getAllComponents)();
        if (componentList.includes(component) || componentList.includes(component))
            return true;
        else
            return false;
    });
    const writeComponent = (component, targetPath) => __awaiter(void 0, void 0, void 0, function* () {
        try {
            // Ensure the destination folder exists or create it
            yield fs_extra_1.default.ensureDir(targetPath);
            yield fs_extra_1.default.copy(path_1.default.join(homeDir, config_1.config.gluestackDir, config_1.config.componentsResourcePath, config_1.config.style, component), path_1.default.join(targetPath), {
                overwrite: true,
            });
        }
        catch (error) {
            prompts_1.log.error(`\x1b[31mError: ${error.message}\x1b[0m`);
        }
    });
    const confirmOverride = (component, existingCount) => __awaiter(void 0, void 0, void 0, function* () {
        const displayComponent = existingCount === 1 ? component[0] : 'Few';
        const shouldContinue = yield (0, prompts_1.confirm)({
            message: `${displayComponent} component/components already exists. Be advised that if there are any changes made in the components, proceeding will result in components being replaced as well. Continue installing component?`,
        });
        return shouldContinue;
    });
});
