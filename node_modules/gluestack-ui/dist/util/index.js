var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
(function (factory) {
    if (typeof module === "object" && typeof module.exports === "object") {
        var v = factory(require, exports);
        if (v !== undefined) module.exports = v;
    }
    else if (typeof define === "function" && define.amd) {
        define(["require", "exports", "os", "path", "util", "fs-extra", "@clack/prompts", "find-package-json", "simple-git", "child_process", "../config"], factory);
    }
})(function (require, exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.addIndexFile = exports.installPackages = exports.getAllComponents = exports.checkIfFolderExists = exports.cloneRepositoryAtRoot = void 0;
    const os_1 = __importDefault(require("os"));
    const path_1 = __importDefault(require("path"));
    const util_1 = __importDefault(require("util"));
    const fs_extra_1 = __importDefault(require("fs-extra"));
    const prompts_1 = require("@clack/prompts");
    const find_package_json_1 = __importDefault(require("find-package-json"));
    const simple_git_1 = __importDefault(require("simple-git"));
    const child_process_1 = require("child_process");
    const config_1 = require("../config");
    const stat = util_1.default.promisify(fs_extra_1.default.stat);
    const homeDir = os_1.default.homedir();
    const currDir = process.cwd();
    const getPackageJsonPath = () => {
        var f = (0, find_package_json_1.default)(currDir);
        return f.next().filename || '';
    };
    const rootPackageJsonPath = getPackageJsonPath();
    const projectRootPath = path_1.default.dirname(rootPackageJsonPath);
    const getAllComponents = () => {
        const componentList = fs_extra_1.default
            .readdirSync(path_1.default.join(homeDir, config_1.config.gluestackDir, config_1.config.componentsResourcePath, config_1.config.style))
            .filter((file) => !['.tsx', '.ts', '.jsx', '.js'].includes(path_1.default.extname(file).toLowerCase()) && file !== config_1.config.providerComponent);
        return componentList;
    };
    exports.getAllComponents = getAllComponents;
    const cloneRepositoryAtRoot = () => __awaiter(void 0, void 0, void 0, function* () {
        const clonedRepoExists = yield checkIfFolderExists(path_1.default.join(homeDir, config_1.config.gluestackDir));
        if (clonedRepoExists) {
            prompts_1.log.step('Repository already cloned.');
            yield pullComponentRepo(path_1.default.join(homeDir, config_1.config.gluestackDir));
        }
        else {
            const s = (0, prompts_1.spinner)();
            s.start('Cloning repository...');
            yield cloneComponentRepo(path_1.default.join(homeDir, config_1.config.gluestackDir), config_1.config.repoUrl);
            s.stop('Repository cloned successfully.');
        }
    });
    exports.cloneRepositoryAtRoot = cloneRepositoryAtRoot;
    const cloneComponentRepo = (targetPath, gitURL) => __awaiter(void 0, void 0, void 0, function* () {
        const git = (0, simple_git_1.default)();
        const s = (0, prompts_1.spinner)();
        s.start('⏳ Cloning repository...');
        try {
            yield git.clone(gitURL, targetPath, [
                '--depth=1',
                '--branch',
                config_1.config.branchName,
            ]);
            s.stop('\x1b[32m' + 'Cloning successful.' + '\x1b[0m');
        }
        catch (err) {
            s.stop('\x1b[31m' + 'Cloning failed' + '\x1b[0m');
            prompts_1.log.error(`\x1b[31mError: ${err.message}\x1b[0m`);
            process.exit(1);
        }
    });
    const pullComponentRepo = (targetpath) => __awaiter(void 0, void 0, void 0, function* () {
        const s = (0, prompts_1.spinner)();
        s.start('⏳ Pulling latest changes...');
        let retry = 0;
        let success = false;
        while (!success && retry < 3) {
            try {
                yield wait(1000);
                yield tryGitPull(targetpath);
                success = true;
            }
            catch (err) {
                prompts_1.log.error(`\x1b[31mError: ${err.message}\x1b[0m`);
                prompts_1.log.error(`\x1b[31mPulling failed - retrying... (Attempt ${retry + 1})\x1b[0m`);
                retry++;
            }
        }
        if (!success)
            s.stop('\x1b[31m' + 'Pulling failed!' + '\x1b[0m');
        else
            s.stop('\x1b[32m' + 'Git pull successful.' + '\x1b[0m');
    });
    const tryGitPull = (targetPath) => __awaiter(void 0, void 0, void 0, function* () {
        const git = (0, simple_git_1.default)(targetPath);
        if (fs_extra_1.default.existsSync(targetPath)) {
            yield git.pull('origin', config_1.config.branchName);
        }
        else
            prompts_1.log.error('\x1b[31m' + 'Target path does not exist' + '\x1b[0m');
    });
    const checkIfFolderExists = (path) => __awaiter(void 0, void 0, void 0, function* () {
        try {
            const stats = yield stat(path);
            return stats.isDirectory();
        }
        catch (error) {
            return false;
        }
    });
    exports.checkIfFolderExists = checkIfFolderExists;
    const wait = (msec) => new Promise((resolve, _) => {
        setTimeout(resolve, msec);
    });
    const detectLockFile = () => {
        const packageLockPath = path_1.default.join(projectRootPath, 'package-lock.json');
        const yarnLockPath = path_1.default.join(projectRootPath, 'yarn.lock');
        const pnpmLockPath = path_1.default.join(projectRootPath, 'pnpm-lock.yaml');
        if (fs_extra_1.default.existsSync(packageLockPath)) {
            return 'npm';
        }
        else if (fs_extra_1.default.existsSync(yarnLockPath)) {
            return 'yarn';
        }
        else if (fs_extra_1.default.existsSync(pnpmLockPath)) {
            return 'pnpm';
        }
        else {
            return null;
        }
    };
    const promptVersionManager = () => __awaiter(void 0, void 0, void 0, function* () {
        const packageManager = yield (0, prompts_1.select)({
            message: 'No lockfile detected. Please select a package manager to install dependencies:',
            options: [
                { value: 'npm', label: 'npm', hint: 'recommended' },
                { value: 'yarn', label: 'yarn' },
                { value: 'pnpm', label: 'pnpm' },
            ],
        });
        if ((0, prompts_1.isCancel)(packageManager)) {
            (0, prompts_1.cancel)('Operation cancelled.');
            process.exit(0);
        }
        return packageManager;
    });
    const addDependencies = (dependenciesToAdd) => __awaiter(void 0, void 0, void 0, function* () {
        const packageJsonPath = rootPackageJsonPath;
        try {
            // Read in the existing package.json file
            const packageJson = JSON.parse(fs_extra_1.default.readFileSync(packageJsonPath, 'utf8'));
            packageJson.dependencies = packageJson.dependencies || {};
            // Add each dependency in the provided format
            dependenciesToAdd.forEach((packageName) => {
                if (packageJson.dependencies[packageName]) {
                    return;
                }
                else {
                    if (config_1.config.packageVersions[packageName]) {
                        packageJson.dependencies[packageName] =
                            config_1.config.packageVersions[packageName];
                    }
                    else if (!packageJson.dependencies[packageName]) {
                        packageJson.dependencies[packageName] = 'latest';
                    }
                }
            });
            // Write the updated package.json file
            fs_extra_1.default.writeFileSync(packageJsonPath, JSON.stringify(packageJson, null, 2));
        }
        catch (err) {
            prompts_1.log.error(`\x1b[31mError: ${err.message}\x1b[0m`);
        }
    });
    const installPackages = (installationMethod, dependencies) => __awaiter(void 0, void 0, void 0, function* () {
        let command;
        if (!installationMethod) {
            let versionManager = detectLockFile();
            if (!versionManager) {
                versionManager = yield promptVersionManager();
            }
            switch (versionManager) {
                case 'npm':
                    command = `npm install --legacy-peer-deps `;
                    break;
                case 'yarn':
                    command = `yarn `;
                    break;
                case 'pnpm':
                    command = `pnpm i --lockfile-only `;
                    break;
                default:
                    throw new Error('Invalid package manager selected');
            }
        }
        else {
            switch (installationMethod) {
                case 'npm':
                    command = `npm install --legacy-peer-deps`;
                    break;
                case 'yarn':
                    command = `yarn `;
                    break;
                case 'pnpm':
                    command = `pnpm i --lockfile-only`;
                    break;
                default:
                    throw new Error('Invalid package manager selected');
            }
        }
        const s = (0, prompts_1.spinner)();
        s.start('⏳ Installing dependencies...');
        try {
            yield addDependencies(dependencies);
            (0, child_process_1.spawnSync)(command, {
                cwd: projectRootPath,
                stdio: 'inherit',
                shell: true,
            });
            s.stop(`\x1b[32mDependencies have been installed successfully.\x1b[0m`);
        }
        catch (err) {
            prompts_1.log.error(`\x1b[31mError: ${err.message}\x1b[0m`);
            prompts_1.log.error('\x1b[31mError installing dependencies:\x1b[0m');
            prompts_1.log.warning(` - Run \x1b[33m'${command}'\x1b[0m manually!`);
            throw new Error('Error installing dependencies.');
        }
    });
    exports.installPackages = installPackages;
    const addIndexFile = (componentsDirectory) => __awaiter(void 0, void 0, void 0, function* () {
        try {
            const directories = yield fs_extra_1.default.readdir(componentsDirectory);
            const componentDirectories = directories.filter((item) => fs_extra_1.default.statSync(path_1.default.join(componentsDirectory, item)).isDirectory());
            // Generate import and export statements for each component directory
            const exportStatements = componentDirectories
                .map((component) => `export * from './${component}';`)
                .join('\n');
            const indexContent = `${exportStatements}\n`;
            yield fs_extra_1.default.writeFile(path_1.default.join(componentsDirectory, 'index.ts'), indexContent);
        }
        catch (err) {
            prompts_1.log.error(`\x1b[31mError: ${err.message}\x1b[0m`);
        }
    });
    exports.addIndexFile = addIndexFile;
    // Function to copy file with checks
    const generateSpecificFile = (sourcePath, targetPath, fileName) => __awaiter(void 0, void 0, void 0, function* () {
        try {
            // Check if file exists at targetPath
            const exists = yield fs_extra_1.default.pathExists(targetPath);
            if (exists) {
                const ifConfirm = yield (0, prompts_1.confirm)({
                    message: `File ${fileName} already exists. Do you want to overwrite it? (yes/no): `,
                });
                if (ifConfirm) {
                    yield fs_extra_1.default.copyFile(sourcePath, targetPath);
                }
                else {
                    prompts_1.log.info(`Creating ${fileName} has been skipped...`);
                    return;
                }
                // return;
            }
            else {
                // File does not exist, proceed with copying
                yield fs_extra_1.default.copyFile(sourcePath, targetPath);
            }
        }
        catch (err) {
            prompts_1.log.error(`\x1b[31mError: ${err.message}\x1b[0m`);
        }
    });
    function replaceRelativeImportInFile(filePath, oldImportPath, newImportPath) {
        return __awaiter(this, void 0, void 0, function* () {
            try {
                let fileContent = fs_extra_1.default.readFileSync(filePath, 'utf8');
                const modifiedContent = fileContent.replace(new RegExp(`import {.*} from ['"]${oldImportPath}['"];`, 'g'), `import { config } from '${newImportPath}';`);
                fs_extra_1.default.writeFileSync(filePath, modifiedContent, 'utf8');
            }
            catch (err) {
                prompts_1.log.error(`Error replacing import statement: ${err}`);
            }
        });
    }
});
